#include "ToolIcon.s3d"
#include "Tool.s3d"
#include "Panel.s3d"

#include "SelectionPanel.s3d"
#include "MeasuringPanel.s3d"

class ToolsMenu
{
	var mActionController;
	var mMenuController;
	
	var mToolsMenuDistanceToController;
	var mToolPanelWidth;
	var mToolPanelHeight;
	var mToolPanelDepth;
	
	var mToolsMenu;
	var mPanels;
	var mPanelsPositionOffset;
	var mPanelsRotationQuaternion;
	
	var mIntersectionPoint;
	
	var mAnimator;
	
	var mCurrentActivePanelIndex;
	var mPreviousActivePanelIndex;
	var mIsToolSelected;
	
	
	var mActionsArray;
	var mActionsArrayIndex;
	var mActionsArraySize;
	
	
	// Public functions
	Draw();
	GetObj();
	GetIndex();
	SetActionAvailable(isActionAvailable);
	GetControllerTipCoordinates();
	GetDirection();
	SetPosition(position);
	Translate(transl);
	GetPosition();
	SetRotationMatrix(matrix);
	GetRotationMatrix();
	Rotate(angle, x, y, z);
	SetRotation(angle, x, y, z);
	LocalToWorld(point);
	Hide();
	Unhide();
	SetScale(x, y, z);
	IsVisible();
	IsCollidingBBox(object);
	
	UpdateLogic(dt, actionController);
	IsIntersectionFound();
	SelectCurrentHoveredTool();
	DeSelectCurrentTool();
	
	UndoLastAction();
	RedoLastAction();
};


function ToolsMenu::ToolsMenu(menuController, actionController)
{
	mMenuController = menuController;
	mActionController = actionController;
	
	mActionsArray = {};
	mActionsArrayIndex = 0;
	mActionsArraySize = 3;
	
	mIntersectionPoint = [0, 0, 0];
	
	mAnimator = Animator();
	
	mCurrentActivePanelIndex = -1;
	mPreviousActivePanelIndex = -1;
	mIsToolSelected = false;
	
	mPanels = {};
	mPanelsPositionOffset = {};
	mPanelsRotationQuaternion = {};
	
	var selectionPanelObj = SelectionPanel(actionController, mAnimator, mActionsArray, &mActionsArrayIndex, &mActionsArraySize);
	var positionOffset = [0, mMenuController.GetHeight() / 2.0, selectionPanelObj.GetHeight() / 3.0];
	var quaternion = EulerToQuaternion([-90, 0, 0]);
	
	outputln(mActionsArraySize);
	
	aadd(mPanels, selectionPanelObj);
	aadd(mPanelsPositionOffset, positionOffset);
	aadd(mPanelsRotationQuaternion, quaternion);
	
	selectionPanelObj = MeasuringPanel(actionController, mAnimator, mActionsArray, &mActionsArrayIndex, &mActionsArraySize);
	positionOffset = [-selectionPanelObj.GetWidth() / 2.0, -selectionPanelObj.GetHeight() / 3.0, mMenuController.GetDepth() / 3.0];
	quaternion = EulerToQuaternion([0, -90, 90]);
	
	aadd(mPanels, selectionPanelObj);
	aadd(mPanelsPositionOffset, positionOffset);
	aadd(mPanelsRotationQuaternion, quaternion);
}

function ToolsMenu::UpdateLogic(dt, actionController)
{
	var rayOrigin = actionController.GetPosition();
	var rayEnd = actionController.GetDirection() * CameraGetCurrent().GetZFar();
	
	var contactDistance = CameraGetCurrent().GetZFar();
	var contactPoint;
	var panelIndex = -1;
	
	// I iterate over all the panels to update their position and to check intersections
	for(var i = 0; i < len(mPanels); i++)
	{
		var panelObj = mPanels[i];
		
		// Updating the position of the panel with respect to the menu controller
		panelObj.SetPosition(mMenuController.LocalToWorld(mPanelsPositionOffset[i]));
		panelObj.SetRotationMatrix(mMenuController.GetRotationMatrix());
		
		var rotation = QuaternionToAxisAngle(mPanelsRotationQuaternion[i]);
		panelObj.Rotate(rotation[3] * RAD_TO_GRAD, rotation.x, rotation.y, rotation.z);
		
		var findContact = false;
		var contactPointTmp;
		
		// Now I need to check if the action controller intersects this panel
		if(panelObj.IsColliding(rayOrigin, rayEnd, &contactPointTmp))
		{
			// If there was an intersection there might be another panel which is actually closer to the action controller; so I need
			// to check if the distance of this panel is lower than the previous distance found (if there was one)
			var distance = Modulus(rayOrigin - contactPointTmp);
			
			// If this panel is closer than the one found before, I save some info
			if(distance < contactDistance)
			{
				contactPoint = contactPointTmp;
				contactDistance = distance;
				panelIndex = i;
			}
		}
				
		// I update the logic of the panel (currently it's only the position of the icons)
		panelObj.UpdateLogic(dt, actionController);
	}
	
	// If a panel was intersected, I check if any icon was intersected, and save the contact point for later (it will be used
	// by the MenuController class to pass it to the ActionController class to draw the ray
	if(panelIndex != -1)
	{
		mCurrentActivePanelIndex = panelIndex;
		
		mPanels[panelIndex].FindIntersection(rayOrigin, rayEnd);
		mIntersectionPoint = contactPoint;
	}
	else
	{
		mCurrentActivePanelIndex = -1;
		mIntersectionPoint = Void;
	}
		
	mAnimator.UpdateTransitions(dt);
}

/*
 * This function returns the contact point found in the last update, or Void if none was found
 */
function ToolsMenu::IsIntersectionFound()
{
	return mIntersectionPoint;
}

function ToolsMenu::SelectCurrentHoveredTool()
{
	if(mPreviousActivePanelIndex != -1)
		mPanels[mPreviousActivePanelIndex].DeSelectCurrentTool();

	mPreviousActivePanelIndex = mCurrentActivePanelIndex;
	
	mIsToolSelected = mPanels[mCurrentActivePanelIndex].SelectCurrentHoveredTool();
}

function ToolsMenu::DeSelectCurrentTool()
{
	if(mIsToolSelected)
		mIsToolSelected = mPanels[mCurrentActivePanelIndex].DeSelectCurrentTool();
		
	mPreviousActivePanelIndex = -1;
}

function ToolsMenu::Draw()
{
	for(var i = 0; i < len(mPanels); i++)
	{
		mPanels[i].Draw();
	}
}

function ToolsMenu::GetObj()
{
	return mToolsMenu.GetObj();
}

//function ToolsMenu::SetActionAvailable(isActionAvailable)
//{
//	mMenuController.SetActionAvailable(isActionAvailable);
//}

function ToolsMenu::SetPosition(position)
{
	mToolsMenu.SetPosition(position);
}

function ToolsMenu::GetPosition()
{
	return mToolsMenu.GetPosition();
}

function ToolsMenu::SetRotationMatrix(matrix)
{
	mToolsMenu.SetRotationMatrix(matrix);
}

function ToolsMenu::GetRotationMatrix()
{
	return mToolsMenu.GetRotationMatrix();
}


function ToolsMenu::Rotate(angle, x, y, z)
{
	mToolsMenu.Rotate(angle, x, y, z);
}

function ToolsMenu::SetRotation(angle, x, y, z)
{
	mToolsMenu.SetRotation(angle, x, y, z);
}

function ToolsMenu::LocalToWorld(point)
{
	return mToolsMenu.LocalToWorld(point);
}

function ToolsMenu::Hide()
{
	mToolsMenu.Hide();
}

function ToolsMenu::Unhide()
{
	mToolsMenu.Unhide();
}

function ToolsMenu::SetScale(x, y, z)
{
	mToolsMenu.SetScale(x, y, z);
}

//function ToolsMenu::IsVisible()
//{
//	return mMenuController.IsVisible();
//}

function ToolsMenu::Translate(transl)
{
	mToolsMenu.Translate(transl);
}

function ToolsMenu::IsCollidingBBox(object)
{
	return mToolsMenu.IsCollidingBBox(object);
}
