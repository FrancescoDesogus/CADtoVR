#include "ActionsListManager.s3d"
#include "ToolsMenu.s3d"

/*
 * This class handles the controller in charge of the menu
 */
class MenuController
{
	// Reference to the vive controller and its index
	var mViveController;
	var mControllerIndex;
	
	// Reference to the action controller. Since most of the work is delegated to the Tool objects and this (indirectly) are
	// managed by the MenuController class, it makes sense to have a reference of the other controller
	var mActionController;
	
	// Reference to the InputManager class
	var mInputManager;
	
	// ToolsMenu object
	var mToolsMenu;
	
	// ActionsListManager object that is in charge of the undo/redo mechanism
	var mActionsListManager;
	
	
	// Public functions
	UpdateLogic(dt, debugMode);
	
	// Common functions
	Draw();
	GetObj();
	GetIndex();
	SetActionAvailable(isActionAvailable);
	GetControllerTipCoordinates();
	GetDirection();
	SetPosition(position);
	Translate(transl);
	GetPosition();
	SetRotationMatrix(matrix);
	GetRotationMatrix();
	Rotate(angle, x, y, z);
	SetRotation(angle, x, y, z);
	LocalToWorld(point);
	Hide();
	Unhide();
	SetScale(x, y, z);
	IsVisible();
	IsCollidingBBox(object);
};

/*
 * Constructor
 * 
 * viveController: reference to the ViveController object
 * actionController: reference to the ActionController object
 * inputManager: reference to the InputManager object
 */
function MenuController::MenuController(viveController, actionController, inputManager)
{
	mViveController = viveController;
	mControllerIndex = mViveController.GetIndex();
	mActionController = actionController;
	mInputManager = inputManager;
	
	// Creating the object that handles undo/redo
	mActionsListManager = ActionsListManager();
	
	// Creating the tool menu object
	mToolsMenu = ToolsMenu(mViveController, actionController, mActionsListManager);
}

/* 
 * This method updates the menu controller logic and that of the menu
 */
function MenuController::UpdateLogic(dt, isVRon)
{
	if(!isVRon)
	{
		static var rotX = 0;
		static var rotY = 0;
		static var rotZ = 0;
			
		if(KeyPressed("F"))
			rotX += 1;
		
		if(KeyPressed("H"))
			rotX -= 1;
			
		if(KeyPressed("T"))
			rotY += 1;
		
		if(KeyPressed("G"))
			rotY -= 1;
			
		if(KeyPressed("R"))
			rotZ += 1;
		
		if(KeyPressed("Y"))
			rotZ -= 1;
		
		mViveController.SetRotation(0, 1, 0, 0);
		mViveController.Rotate(rotY, 1, 0, 0);
		mViveController.Rotate(rotX, 0, 1, 0);
		mViveController.Rotate(rotZ, 0, 0, 1);
		
		
		static var xOffset = 0;
		static var yOffset = 0;
		static var zOffset = 0;
		
		if(KeyPressed("L"))
			xOffset += 0.05 * SCALE_FACTOR;
		
		if(KeyPressed("J"))
			xOffset -= 0.05 * SCALE_FACTOR;
			
		if(KeyPressed("I"))
			zOffset += 0.05 * SCALE_FACTOR;
		
		if(KeyPressed("K"))
			zOffset -= 0.05 * SCALE_FACTOR;
			
//		if(KeyPressed(VK_NUMPAD1))
//			yOffset += 1.0 * SCALE_FACTOR;
//		
//		if(KeyPressed(VK_RSHIFT))
//			yOffset -= 1.0 * SCALE_FACTOR;
//			

		mViveController.SetPosition(mViveController.GetPosition() + [xOffset, yOffset, zOffset]);
	}
	
	
	// Updating the logic of the menu. It will update its position with respect to the controller and will check if 
	// the action controller intersects the menu
	mToolsMenu.UpdateLogic(dt);
	
	// If the action controller intersects the tool panel, this method retrieves the contact point (which is void if no intersection is found)
	var contactPoint = mToolsMenu.IsIntersectionFound();
	
	var intersectionWasFound = contactPoint != Void;
	
	// In case there was an intersection, I tell the action controller to draw the ray from the controller to the contact point found.
	// If there wasn't an intersection, I call the method anyway to stop the rendering of the ray, in case it was being drawn before
	mActionController.SetDrawRay(intersectionWasFound, contactPoint);
	
	if(intersectionWasFound)
	{
		if(mInputManager.PrimaryButtonSinglePressed(mActionController.GetIndex()))
		{
			mToolsMenu.SelectCurrentHoveredTool();
		}
	}
	
	if(mInputManager.GripSinglePressed(mViveController.GetIndex()))
	{
		mToolsMenu.DeSelectCurrentTool();
	}
	
	if(mInputManager.TouchpadLeftSinglePressed(mViveController.GetIndex()))
		mActionsListManager.UndoLastAction();
	else if(mInputManager.TouchpadRightSinglePressed(mViveController.GetIndex()))
		mActionsListManager.RedoLastAction();
		
		
//	if(mInputManager.TouchpadLeftSinglePressed(mViveController.GetIndex()))
//		mToolsMenu.RotatePanels(true);
//	else if(mInputManager.TouchpadRightSinglePressed(mViveController.GetIndex()))
//		mToolsMenu.RotatePanels(false);
//	if(mInputManager.TouchpadLeftSinglePressed(mViveController.GetIndex()))
//		mAnimator.CreateRotatingTransition(mToolsMenu.GetObj(), 0, -90, [0, 1, 0], 1.0, false, false);
//	else if(mInputManager.TouchpadRightSinglePressed(mViveController.GetIndex()))
//		mAnimator.CreateRotatingTransition(mToolsMenu.GetObj(), 0, 90, [0, 1, 0], 1.0, false, false);
}

function MenuController::Draw()
{
	mViveController.Draw(VR_NO_CULLING);

	mToolsMenu.Draw();
}

function MenuController::GetObj()
{
	return mViveController.GetObj();
//	return mMenuController;
}

function MenuController::GetIndex()
{
	return mControllerIndex;
}

function MenuController::SetActionAvailable(isActionAvailable)
{
	mViveController.SetActionAvailable(isActionAvailable);
}

function MenuController::GetControllerTipCoordinates()
{
	return mViveController.GetControllerTipCoordinates();
}

function MenuController::GetDirection()
{
	return mViveController.GetDirection();
}

function MenuController::SetPosition(position)
{
	mViveController.SetPosition(position);
}

function MenuController::GetPosition()
{
	return mViveController.GetPosition();
}

function MenuController::SetRotationMatrix(matrix)
{
	mViveController.SetRotationMatrix(matrix);
}

function MenuController::GetRotationMatrix()
{
	return mViveController.GetRotationMatrix();
}


function MenuController::Rotate(angle, x, y, z)
{
	mViveController.Rotate(angle, x, y, z);
}

function MenuController::SetRotation(angle, x, y, z)
{
	mViveController.SetRotation(angle, x, y, z);
}

function MenuController::LocalToWorld(point)
{
	return mViveController.LocalToWorld(point);
}

function MenuController::Hide()
{
	mViveController.Hide();
}

function MenuController::Unhide()
{
	mViveController.Unhide();
}

function MenuController::SetScale(x, y, z)
{
	mViveController.SetScale(x, y, z);
}

function MenuController::IsVisible()
{
	return mViveController.IsVisible();
}

function MenuController::Translate(transl)
{
	mViveController.Translate(transl);
}

function MenuController::IsCollidingBBox(object)
{
	return mViveController.IsCollidingBBox(object);
}
